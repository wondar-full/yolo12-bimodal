"""
æ™ºèƒ½éªŒè¯åŠ©æ‰‹ï¼šè‡ªåŠ¨æ£€æµ‹æ¨¡å‹é€šé“æ•°å¹¶ä½¿ç”¨æ­£ç¡®çš„æ•°æ®é…ç½®

ä½¿ç”¨æ–¹æ³•:
    python smart_val.py --model models/yolo12x.pt
    python smart_val.py --model runs/train/phase3_channelc2f7/weights/best.pt
"""

import argparse
import torch
from pathlib import Path
import subprocess

def detect_model_channels(model_path):
    """æ£€æµ‹æ¨¡å‹æœŸæœ›çš„è¾“å…¥é€šé“æ•°"""
    try:
        ckpt = torch.load(model_path, map_location='cpu')
        
        # æ–¹æ³•1: æ£€æŸ¥ YAML é…ç½®
        if 'model' in ckpt and hasattr(ckpt['model'], 'yaml'):
            yaml_cfg = ckpt['model'].yaml
            if 'ch' in yaml_cfg:
                return yaml_cfg['ch']
        
        # æ–¹æ³•2: æ£€æŸ¥ç¬¬ä¸€å±‚å·ç§¯
        if 'model' in ckpt:
            model = ckpt['model']
            for module in model.modules():
                if isinstance(module, torch.nn.Conv2d):
                    return module.in_channels
        
        return None
    except Exception as e:
        print(f"âš ï¸  Failed to detect channels: {e}")
        return None


def main():
    parser = argparse.ArgumentParser(description="Smart validation with auto channel detection")
    parser.add_argument('--model', type=str, required=True, help='Path to model weights')
    parser.add_argument('--batch', type=int, default=16, help='Batch size')
    parser.add_argument('--device', type=int, default=0, help='GPU device')
    args = parser.parse_args()
    
    model_path = Path(args.model)
    if not model_path.exists():
        print(f"âŒ Model not found: {model_path}")
        return
    
    print("=" * 80)
    print("ğŸ” Smart Validation Assistant")
    print("=" * 80)
    print()
    print(f"Model: {model_path}")
    print()
    
    # æ£€æµ‹é€šé“æ•°
    print("Detecting model input channels...")
    channels = detect_model_channels(model_path)
    
    if channels is None:
        print("âš ï¸  Failed to detect channels, assuming RGB-only (3 channels)")
        channels = 3
    else:
        print(f"âœ… Detected: {channels} channels")
    print()
    
    # é€‰æ‹©æ•°æ®é…ç½®
    if channels == 3:
        print("ğŸ“‹ Using RGB-only configuration")
        data_cfg = "data/visdrone-rgb-only.yaml"
        val_script = "val_rgb_only.sh"
    elif channels == 4:
        print("ğŸ“‹ Using RGB-D configuration")
        data_cfg = "data/visdrone-rgbd.yaml"
        val_script = "val_depth.sh"
    else:
        print(f"âš ï¸  Unknown channel count: {channels}")
        print("   Using RGB-only as fallback")
        data_cfg = "data/visdrone-rgb-only.yaml"
        val_script = "val_rgb_only.sh"
    
    print(f"Data config: {data_cfg}")
    print(f"Val script:  {val_script}")
    print()
    
    # æ£€æŸ¥é…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if not Path(data_cfg).exists():
        print(f"âŒ Data config not found: {data_cfg}")
        if channels == 3:
            print("\nğŸ’¡ Creating RGB-only config...")
            create_rgb_only_config()
    
    # è¿è¡ŒéªŒè¯
    print("=" * 80)
    print("Starting validation...")
    print("=" * 80)
    print()
    
    cmd = [
        "bash", val_script,
        str(model_path),
        data_cfg,
        str(args.batch),
        "640",
        str(args.device)
    ]
    
    subprocess.run(cmd)


def create_rgb_only_config():
    """åˆ›å»º RGB-only æ•°æ®é…ç½®"""
    config_content = """# VisDrone Dataset Configuration (RGB-only, no depth)
# Auto-generated by smart_val.py

path: /data2/user/2024/lzy/Datasets/VisDrone2019-DET-YOLO/VisDrone2YOLO/VisDrone2019-DET-val

train: images/rgb
val: images/rgb

names:
  0: pedestrian
  1: people
  2: bicycle
  3: car
  4: van
  5: truck
  6: tricycle
  7: awning-tricycle
  8: bus
  9: motor

nc: 10

visdrone_mode: true
small_thresh: 1024
medium_thresh: 9216
"""
    
    with open("data/visdrone-rgb-only.yaml", "w") as f:
        f.write(config_content)
    
    print("âœ… Created data/visdrone-rgb-only.yaml")


if __name__ == "__main__":
    main()
